-- Create enum for transaction types
DROP TYPE IF EXISTS transaction_type CASCADE;
CREATE TYPE transaction_type AS ENUM (
  'MINT',
  'BURN',
  'WITHDRAWAL',
  'DEPOSIT',
  'BUY',
  'SELL',
  'TRANSFER',
  'TREASURY'
);

-- Create the essence transactions history table
DROP TABLE IF EXISTS essence_transactions_history CASCADE;
CREATE TABLE IF NOT EXISTS essence_transactions_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  transaction_hash VARCHAR(66) NOT NULL UNIQUE,
  block_number BIGINT NOT NULL DEFAULT 0,
  timestamp TIMESTAMPTZ NOT NULL,
  from_address VARCHAR(42) NOT NULL,
  to_address VARCHAR(42) NOT NULL,
  value TEXT NOT NULL, -- Changed from NUMERIC to TEXT to store exact string values
  transaction_type VARCHAR(20) NOT NULL CHECK (transaction_type IN ('MINT', 'BURN', 'WITHDRAWAL', 'DEPOSIT', 'BUY', 'SELL', 'TRANSFER', 'TREASURY')),
  gas_used NUMERIC(78, 0) DEFAULT 0,
  gas_price NUMERIC(78, 0) DEFAULT 0,
  method_id VARCHAR(10) DEFAULT '',
  method_name VARCHAR(100) DEFAULT '',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_essence_tx_timestamp ON essence_transactions_history(timestamp);
CREATE INDEX IF NOT EXISTS idx_essence_tx_type ON essence_transactions_history(transaction_type);
CREATE INDEX IF NOT EXISTS idx_essence_tx_from ON essence_transactions_history(from_address);
CREATE INDEX IF NOT EXISTS idx_essence_tx_to ON essence_transactions_history(to_address);

-- Create aggregated stats table for quick access to important metrics
DROP TABLE IF EXISTS essence_stats_daily CASCADE;
CREATE TABLE IF NOT EXISTS essence_stats_daily (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  date DATE NOT NULL UNIQUE,
  total_minted TEXT NOT NULL DEFAULT '0', -- Changed from NUMERIC to TEXT
  total_burned TEXT NOT NULL DEFAULT '0', -- Changed from NUMERIC to TEXT
  total_withdrawn TEXT NOT NULL DEFAULT '0', -- Changed from NUMERIC to TEXT
  total_deposited TEXT NOT NULL DEFAULT '0', -- Changed from NUMERIC to TEXT
  total_bought TEXT NOT NULL DEFAULT '0', -- Changed from NUMERIC to TEXT
  total_sold TEXT NOT NULL DEFAULT '0', -- Changed from NUMERIC to TEXT
  total_treasury TEXT NOT NULL DEFAULT '0', -- Treasury transactions
  unique_buyers INT NOT NULL DEFAULT 0,
  unique_sellers INT NOT NULL DEFAULT 0,
  transaction_count INT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create index for date lookups
CREATE INDEX IF NOT EXISTS idx_essence_stats_date ON essence_stats_daily(date);

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create triggers for updated_at
DROP TRIGGER IF EXISTS update_essence_tx_modtime ON essence_transactions_history;
CREATE TRIGGER update_essence_tx_modtime
    BEFORE UPDATE ON essence_transactions_history
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_essence_stats_modtime ON essence_stats_daily;
CREATE TRIGGER update_essence_stats_modtime
    BEFORE UPDATE ON essence_stats_daily
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Create materialized view for quick access to total stats
DROP VIEW IF EXISTS essence_total_stats CASCADE;
CREATE MATERIALIZED VIEW essence_total_stats AS
SELECT
    COALESCE(SUM(CASE WHEN transaction_type = 'MINT' THEN value::numeric / 1e18 ELSE 0 END), 0)::TEXT as total_minted,
    COALESCE(SUM(CASE WHEN transaction_type = 'BURN' THEN value::numeric / 1e18 ELSE 0 END), 0)::TEXT as total_burned,
    COALESCE(SUM(CASE WHEN transaction_type = 'WITHDRAWAL' THEN value::numeric / 1e18 ELSE 0 END), 0)::TEXT as total_withdrawn,
    COALESCE(SUM(CASE WHEN transaction_type = 'DEPOSIT' THEN value::numeric / 1e18 ELSE 0 END), 0)::TEXT as total_deposited,
    COALESCE(SUM(CASE WHEN transaction_type = 'BUY' THEN value::numeric / 1e18 ELSE 0 END), 0)::TEXT as total_bought,
    COALESCE(SUM(CASE WHEN transaction_type = 'SELL' THEN value::numeric / 1e18 ELSE 0 END), 0)::TEXT as total_sold,
    COALESCE(SUM(CASE WHEN transaction_type = 'TREASURY' THEN value::numeric / 1e18 ELSE 0 END), 0)::TEXT as total_treasury,
    COUNT(DISTINCT CASE WHEN transaction_type = 'BUY' THEN from_address END) as unique_buyers_all_time,
    COUNT(DISTINCT CASE WHEN transaction_type = 'SELL' THEN from_address END) as unique_sellers_all_time,
    COUNT(*) as total_transactions
FROM essence_transactions_history;

-- Create function to refresh materialized view
CREATE OR REPLACE FUNCTION refresh_essence_total_stats()
RETURNS TRIGGER AS $$
BEGIN
    REFRESH MATERIALIZED VIEW essence_total_stats;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger to refresh materialized view
DROP TRIGGER IF EXISTS refresh_essence_total_stats_trigger ON essence_transactions_history;
CREATE TRIGGER refresh_essence_total_stats_trigger
    AFTER INSERT OR UPDATE OR DELETE ON essence_transactions_history
    FOR EACH STATEMENT
    EXECUTE FUNCTION refresh_essence_total_stats();

-- Create sync status table for tracking progress
DROP TABLE IF EXISTS essence_sync_status CASCADE;
CREATE TABLE IF NOT EXISTS essence_sync_status (
  id INTEGER PRIMARY KEY,
  last_sync TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_timestamp BIGINT NOT NULL DEFAULT 0,
  transactions_processed BIGINT NOT NULL DEFAULT 0,
  has_more BOOLEAN NOT NULL DEFAULT true
);

-- Insert initial sync status record if it doesn't exist
INSERT INTO essence_sync_status (id, last_sync, last_timestamp, transactions_processed, has_more)
VALUES (1, NOW(), 0, 0, true)
ON CONFLICT (id) DO NOTHING; 